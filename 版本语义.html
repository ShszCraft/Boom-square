语义版本2.0.0
概要
给定版本号MAJOR.MINOR.PATCH，增加：

MAJOR版本，当你做出不兼容的API更改时，
MINOR版本，当您以向后兼容的方式添加功能时，以及
当您进行向后兼容的错误修复时，请使用修补程序版本。
预发布和构建元数据的其他标签可作为MAJOR.MINOR.PATCH格式的扩展。

介绍
在软件管理的世界里，存在一个叫做“依赖地狱”的恐惧之地。你的系统越发壮大，你整合到软件中的软件包越多，有一天，你越有可能在这个绝望的坑中找到自己。

在有很多依赖关系的系统中，发布新的软件包版本很快就会变成一场噩梦。如果依赖性规范过于紧张，则存在版本锁定的危险（无需发布每个相关软件包的新版本就无法升级软件包）。如果依赖关系被指定得太松，你将不可避免地被版本混淆所困扰（假设与未来版本的兼容性比合理）。当版本锁定和/或版本混杂性阻止您轻松安全地移动项目时，依赖地狱就是您的所在。

作为解决这个问题的方法，我提出了一套简单的规则和要求，规定版本号如何分配和递增。这些规则基于但不一定限于在封闭和开源软件中使用的预先存在的广泛的通用实践。为了使这个系统起作用，你首先需要声明一个公共API。这可能由文档组成，也可能由代码本身强制执行。无论如何，重要的是这个API应该是清楚而准确的。一旦确定了您的公共API，您就可以通过特定的增量与您的版本号进行更改。考虑XYZ（Major.Minor.Patch）的版本格式。错误修复不会影响API增加修补程序版本，向后兼容API添加/更改递增次要版本，向后不兼容的API更改递增主版本。

我把这个系统称为“语义版本化”。在这个方案下，版本号和它们改变的方式传达了底层代码的意义以及从一个版本到下一个版本的修改。

语义版本规范（SemVer）
本文件中的“必须”，“不得”，“需要”，“应”，“不应”，“应该”，“不应该”，“推荐”，“可能”和“可选”按照RFC 2119中的描述进行解释。

使用语义版本控制的软件必须声明一个公共API。这个API可以在代码本身声明或严格存在于文档中。然而，它已经完成，它应该是精确和全面的。

一个正常的版本号必须采用XYZ的形式，其中X，Y和Z是非负整数，并且不能包含前导零。X是主版本，Y是次版本，Z是补丁版本。每个元素必须在数字上增加。例如：1.9.0 - > 1.10.0 - > 1.11.0。

一旦版本化的软件包发布，该版本的内容不得修改。任何修改都必须作为新版本发布。

主版本零（0.yz）用于初始开发。任何事情随时都可能改变。公共API不应该被认为是稳定的。

版本1.0.0定义了公共API。在这个版本之后版本号增加的方式取决于这个公共API以及它的变化。

如果仅引入向后兼容的错误修复，则修补程序版本Z（xyZ | x> 0）务必增加。错误修复被定义为修复错误行为的内部更改。

如果向公共API引入了新的向后兼容功能，则必须增加次要版本Y（xYz | x> 0）。如果任何公共API功能被标记为弃用，它必须增加。如果在私有代码中引入了重要的新功能或改进，它可能会增加。它可能包含修补程序级别的更改。当次版本递增时，补丁版本必须重置为0。

如果向公共API引入任何向后不兼容的更改，则必须增加主版本X（Xyz | X> 0）。它可能包含次要和补丁级别的变化。主要版本增加时，补丁和次要版本必须重置为0。

预发布版本可以通过在补丁版本之后立即附加连字符和一系列点分隔标识符来表示。标识符必须只包含ASCII字母数字和连字符[0-9A-Za-z-]。标识符不能为空。数字标识符不能包含前导零。预发布版本的优先级低于关联的普通版本。预发布版本表示版本不稳定，可能无法满足其相关正常版本所表示的预期兼容性要求。示例：1.0.0-alpha，1.0.0-alpha.1,1.0.0-0.3.7,1.0.0-x.7.z.92。

构建元数据可以通过在补丁或预发布版本之后立即附加加号和一系列点分隔标识符来表示。标识符必须只包含ASCII字母数字和连字符[0-9A-Za-z-]。标识符不能为空。确定版本优先级时，应该忽略构建元数据。因此，仅在构建元数据中有所不同的两个版本具有相同的优先级。示例：1.0.0-alpha + 001,1.0.0 + 20130313144700,1.0.0-beta + exp.sha.5114f85。

优先级指的是在订购时如何比较各个版本。优先级必须按照该顺序将版本分为主版本，次版本，补丁版本和预发布版本标识符（生成元数据不会成为优先级）。当从左到右比较每个标识符时，优先级由第一个差异决定，如下所示：主版本，次版本和补丁版本始终以数字形式进行比较。例如：1.0.0 <2.0.0 <2.1.0 <2.1.1。当主要版本，次要版本和补丁相同时，预发布版本的优先级低于普通版本。例如：1.0.0-alpha <1.0.0。具有相同主版本，次版本和补丁版本的两个预发布版本的优先级必须通过比较每个点分隔的标识符从左到右直到找到差异来确定，如下所示：在数字上比较仅包含数字的标识符，并且使用字母或连字符的标识符按照ASCII排序顺序进行词汇比较。数字标识符的优先级始终低于非数字标识符的优先级。如果所有前面的标识符都相等，则更大的预发布字段集的优先级高于较小的集。示例：1.0.0-alpha <1.0.0-alpha.1 <1.0.0-alpha.beta <1.0.0-beta <1.0.0-beta.2 <1.0.0-beta.11 <1.0.0- rc.1 <1.0.0。

为什么要使用语义版本？
这不是一个新的或革命性的想法。事实上，你可能已经做了一些接近这一点。问题是“接近”不够好。如果不遵守某种形式的规范，版本号对于依赖管理来说基本上是无用的。通过给上述想法提供一个名称和明确的定义，将您的意图传达给软件用户变得非常容易。一旦这些意图明确，最终可以制定灵活（但不太灵活）的依赖性规范。

一个简单的例子将演示语义版本化如何使依赖地狱成为过去的事情。考虑一个名为“Firetruck”的库。它需要一个名为“Ladder”的语义版本化包。在创建Firetruck时，Ladder的版本为3.1.0。由于Firetruck使用3.1.0中首次引入的一些功能，因此可以安全地将Ladder依赖性指定为大于或等于3.1.0但小于4.0.0。现在，当梯子版本3.1.1和3.2.0可用时，您可以将它们发布到您的软件包管理系统，并知道它们将与现有的依赖软件兼容。

作为一名负责任的开发人员，您当然会想要验证任何软件包升级的功能与所宣传的功能相同。现实世界是一个混乱的地方; 对此我们无能为力，但要保持警惕。您可以做的是让Semantic Versioning为您提供一种理想的方式来发布和升级软件包，而无需滚动依赖软件包的新版本，节省时间和麻烦。

如果所有这些听起来都合情合理，那么开始使用语义版本控制所需要做的就是声明您正在这样做，然后遵循规则。从您的自述文件链接到此网站，以便其他人知道规则并可从中受益。

常问问题
我应该如何处理0.yz初始开发阶段的修订？
最简单的做法是以0.1.0开始您的初始开发版本，然后为每个后续版本增加次要版本。

我如何知道何时发布1.0.0？
如果你的软件在生产中使用，它应该可能已经是1.0.0。如果你有一个用户依赖的稳定的API，你应该是1.0.0。如果你担心向后兼容性，你应该已经是1.0.0了。

这不妨碍快速发展和快速迭代吗？
主要版本零都是关于快速发展。如果你每天都在更改API，你应该仍然在版本0.yz中，或者在一个单独的开发分支上工作下一个主要版本。

如果即使是最小的向后不兼容的公共API更改需要一个主要的版本碰撞，我会不会非常迅速地结束在版本42.0.0？
这是一个负责任的发展和远见的问题。不兼容的更改不应该轻微引入具有大量相关代码的软件。升级必须承担的成本可能很大。不得不通过主要版本来释放不兼容的更改意味着您会考虑更改的影响，并评估涉及的成本/收益率。

记录整个公共API是太多工作了！
作为专业开发人员，您有责任正确记录旨在供他人使用的软件。管理软件复杂性是保持项目高效的一个非常重要的部分，如果没有人知道如何使用您的软件，或者有什么方法可以安全地调用，这很难做到。从长远来看，语义版本控制以及坚持定义良好的公共API可以使每个人和每件事情顺利进行。

如果我意外地将后向不兼容的更改作为次要版本发布，我该怎么办？
只要您意识到已经破坏了语义版本控制规范，就可以解决问题并发布一个新的次要版本来纠正问题并恢复向后兼容性。即使在这种情况下，修改版本化版本也是不可接受的。如果合适，请记录违规版本并通知用户该问题，以便他们知道违规版本。

如果我在不更改公共API的情况下更新自己的依赖项，该怎么办？
这会被认为是兼容的，因为它不会影响公共API。明确依赖于您的软件包的相同依赖项的软件应该有自己的依赖性规范，作者将注意到任何冲突。确定更改是否为补丁级别或次要级别修改取决于您是否更新了依赖项以修复错误或引入新功能。我通常会希望为后一种情况提供额外的代码，在这种情况下，它显然是次要级别的增量。

如果我以不符合版本号更改的方式无意中更改了公共API（即代码错误地引入了修补程序版本中的重大更改），该怎么办？
用你最好的判断力。如果您的观众人数众多，将行为改回公众API的行为会受到严重影响，那么最好是执行主要版本发布，尽管修正可能严格视为修补程序发布。请记住，语义版本控制是关于版本号如何变化的意义。如果这些更改对用户很重要，请使用版本号通知他们。

我应该如何处理弃用功能？
贬低现有功能是软件开发的正常组成部分，通常需要取得进展。当您弃用部分公共API时，您应该做两件事：（1）更新您的文档以让用户知道有关更改，（2）发布新的次要版本，并取消弃用。在完全删除新主要版本中的功能之前，应该至少有一个包含弃用的次要版本，以便用户可以平滑地转换到新的API。

semver对版本字符串有大小限制吗？
不，但要善于判断。例如，255个字符的版本字符串可能是矫枉过正的。而且，特定的系统可能会对字符串的大小施加自己的限制。